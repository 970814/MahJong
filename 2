
麻雀 和了判定（役の判定） アルゴリズム

最終更新日：2008/4/9

麻雀の和了判定を高速に行う方法について説明する。

和了の判定は通常バックトラック法を用いて行うが、バックトラック法は面子候補の組み合わせを総当たりで調べるため、処理に時間がかかるという問題がある。 1回実行するだけの場合は処理時間が問題になることはないが、思考ルーチンなどで繰り返し判定処理を行うような場合に、高速に処理できることが要求される。この記事では、そのような場合にインデックスを用いると高速に判定を行えること説明する。

まず、通常法方法を説明した後、インデックスを用いた方法を紹介する。

////////////////////////////////////////////
麻将（角色的判定）算法
最后更新一天：2008 / 9 / 9
关于麻将的和进行判定为快速进行的方法说明。
的判定通常用背方式法进行，不过，倒车法法决定以面子候选的组合为全体调查，处理有时间的问题。
如果只是实行1次的情况下，处理时间不是问题，但在思考程序等进行反复进行判定的情况下，要求能够快速处理。
这个报道，在那样的情况下使用索引和快速进行判定。
首先，说明通常法方法后，介绍一个指数的方法。
////////////////////////////////////////////


通常の方法（バックトラック法）

手牌を１つの雀頭と４つの面子に分けることができれば和了の形となる。（七対子と国士無双は例外）

雀頭と４つの面子を構成する牌が重ならない場合は、どのような順番で取り出しても判定することができる。しかし、雀頭と４つの面子を構成する牌が重なる場合は、ひとつの牌を雀頭とも面子ともとらえることができてしまう。たとえば、１２３３３３４５という牌の時、３を雀頭ととらえれば、残った１２３、３４５を面子として取り出すことができるが、３を面子（刻子）ととらえると、１２３４５が残り、雀頭を取り出すことができない。

したがって、雀頭と面子の候補をすべて試して和了の形になるかを調べる必要がある。このような組み合わせを全て調べる方法に対して、バックトラック法が用いられる。

バックトラック法を適用するにあたり、雀頭が必ずひとつであることを利用すると、雀頭→面子の順に取り出した方が、やり直しの回数が少なくて済む。面子の取り出し方は、刻子を先に取り出すか、順子を先に取り出すかは、どちらか一方に決めることはできない。麻雀の和了は、点数の高い方を採用するというルールであるため、たとえば、１１１２２２３３３を３つの刻子ととらえるか、３つの順子ととらえるかは、残りの雀頭と面子により役がどうかわるかによる。残りが１・９を含む雀頭と順子の場合は、平和、純チャン、一盃口となり、順子ととらえるより点数が高くなる。そうでない場合は、一盃口より、三暗刻ととらえた方がよく、刻子として取り出した方がよいことになる。つまり、取り出し方が複数ある場合は、和了の候補として残し、それらの点数を調べた上で決定する必要がある。ただし、刻子と順子の取り出し順が問題になるのは先ほどの三暗刻と一盃口の場合だけであり、刻子と順子を交互に取り出すようなパターンは不要である。 したがって、雀頭→刻子→順子、雀頭→順子→刻子の２通りの順序を試せばよいということになる。

通常、面子を構成する牌の重なりはそれほど多くないため、調べる組み合わせの数は多くない。しかし、清一のような手牌が一種類の牌で構成される和了の場合は、組み合わせの数が多くなり、処理時間の増加が懸念される。手牌により処理時間がどのように変わるか調べた結果は以下の通りである。
///////////////////////////////////////////////////////////////
通常的方法（回
如果可以把手牌分成一个的麻雀和四个面子的事，就成了和。（七対子、无双例外）
麻雀头和4个面子构成的牌很不重叠时，怎样的顺序来判定取出也可以。
但是，如果有麻雀头和四个面子的牌重叠的场合，一个的牌的话就可以捕捉了。
比如说，12333345牌的时候，3头和とらえれ麻雀，就剩了123 345为面子，作为可以取出，三面子（刻子）和捕捉，有残り12345，麻雀头不能取出。
因此，必要调查麻雀头和面子的候选人都要尝试了。针对这种组合的方法，在背卡车法使用。
适用于下一次的卡车法时，麻雀头一定会有一个的话，就在麻雀、面子的顺序中取出的人，重新开始的次数也少了。
面子，取出方法，刻子先取出，顺子先取出呢，哪一方无法决定。
麻将和了分数高的人采用的规则，因为，例如，111222333 3个刻子捉住。3个顺子和捕捉吗，残り麻雀头和面子比角色请根据结束？。
如果有9・9的麻雀和顺子的话，和平，纯，一杯口，和顺子相比，分数更高。
如果不这样，一杯口中，三黑暗刻和把握好，作为刻子取出的比较好。
也就是说，如果取出方有复数的情况下，就应作为和已经作为候补的候补而存在，在调查它们的分数后决定。
但是，刻子和顺子的取出顺序成为问题，是刚才的三黑暗刻和一杯口的情况只有，刻子和顺子交替取出的模式是不需要。
因此，麻雀，麻雀刻子头→→→→顺子头顺子刻子的2种循序尝试就好了。
通常，因为构成面子的牌的重合是那么多，调查组合的数不多。
但是，清一样的手牌一种牌构成和了的场合，组合的数量越多，处理时间的增加，担心。
根据手牌的处理时间如何变化的结果是以下的大街。
///////////////////////////////////////////////////////////////
【10万回実行時の処理時間】（Java5、Pentium4 3.0GHzでの測定結果）

手牌：１２３５６７一二三五六七西西
バックトラック法    4297ms

手牌： １１１２３４６７８東東東西西
バックトラック法    4391ms

手牌：１１１２２２２３３３３４４４
バックトラック法    4891ms

重なりが多いほど、処理時間が増えていることが確認できる。
インデックスを用いた方法
//////////////////////////////////////////////////////////////////////////
【10万次运行时的处理时间】（Java 5，奔腾4 3.0 GHz的测量结果）
手牌：123567一二三五六七西西
背景音乐法4297 ms
手牌：111234678东东西西
背景音乐法4391 ms
手牌：11122223333444
背景音乐法4891 ms
越是沉重，处理时间不断增加。
//////////////////////////////////////////////////////////////////////////
和了の形をあらかじめ調べておき、インデックスとして保持しておくことで、インデックスの検索だけで和了の判定を行う方法である。
単純に和了の形を牌の組み合わせとして保持すると、組み合わせの数は約1,700万通り※あるため、牌の種類34種を6bitで表すとした場合、14枚の組み合わせに6×14=84bit必要となり、1,700万通りを保持するには、少なくとも84bit× 1,700万= 1,428,000,000bit=約1.4Gbit=約175MBの記憶領域が必要となる。
※ http://www10.plala.or.jp/rascalhp/mjmath.htm

一般的なパソコン のメモリが1GB程度であることを考えれば、和了の牌の組み合わせをそのまま保持することも可能である。しかし、記憶領域を押さえつつ保持できる方法があ れば、そちらの方法の方が望ましいと言える。
連続した牌の数をインデックスにする方法
/////////////////////////////////////////////////////////////////////////////////
用索引方法
预先调查的形式预先预先调查，作为一个指数的检索，是通过检索检索的检索方法。
单纯的形状和了牌组合而保持，组合的数量大约是1，700万种※，因为牌的种类34种6位表示的场合，14枚的组合6×14 = 84位的必要了，一，700万那样保持，至少84 bit×1，700万= 1万1000位，，，428 =约1.4 Gbit =约1750 MB的记忆领域的必要。
://※http www 10 . plala . or . jp / rascalhp / mjmath .格式
如果考虑一般的电脑内存为1 GB左右的事，就可以直接保持和“一组的牌组合”。但是，如果能在记忆领域能保持的方法的话，可以说是最好的方法。
//////////////////////////////////////////////////////////////////////////////////
和了の形か判断するために、牌が萬子の１であるか、索子の１であるかは重要ではない。１２３のように数字が連続しているかどうかと牌の個数がわかれば十分である。したがって、連続している牌を個数の列に置き換えることで、調べる和了の組み合わせの数を減らすことができる。具体的な例を示すと次のように置き換える。

「１２３」→「１１１」
「５６７」→「１１１」
「１１１」→「３」
「３３３」→「３」
「２３４４５６」→「１１２１１」

異なる牌の組み合わせでも同じ数字の列に置き換わっていることがわかると思う。手牌がすべて連続することは通常ないため、手牌は、連続した数字の個数の複数の組で表現される。このように、牌の組み合わせをを連続した牌の個数の組に置き換えたものをインデックスとして利用することにする。インデックスを数値として扱えた方が便利なため、連続する牌の組同士を「０」でつなげてひとつの数字で表現する。そうすると手牌は次のような数字に置き換えられる。

「１２３５６７一二三五六七西西」→「１１１０１１１０１１１０１１１０２」

「１１１２３４６７８東東東西西」→「３１１１０１１１０３０２」

「１１１２２２２３３３３４４４」→「３４４３」

数値化した和了の形をインデックスとして保持し、和了かどうかの判定にインデックスを検索する場合、数値を比較する処理が必要になる。一般的なパソコンが32bitのコンピュータであるため、数値を比較するとき、数値が32bit以内であれば、扱いやすくなる。手牌を上記のルールに従って数値化した場合、最悪次のような長さの数値になる。

「１３５７９一三五七九東南西北」→「１０１０１０１０１０１０１０１０１０１０１０１０１０１」（27桁）

同じ牌の個数が4枚までなので、1桁を3bitで表すと3bit×27桁=81bit必要になる。このままでは、インデックスとして扱いにくい。そこで、「０」が2個以上続くことがないことを利用して、０をそのひとつ前の数字をセットにして、次のようなルールに従ってビット列に符号化を行う。

「１」→「０」
「２」→「１１０」
「３」→「１１１１０」
「４」→「１１１１１１０」
「１０」→「１０」
「２０」→「１１１０」
「３０」→「１１１１１０」
「４０」→「１１１１１１１０」

数字列を上記の符号化ルールに従ってビット列に変換する場合、次の数値が「０」かどうかに関わらず、以下のルールでビット列に符号化し、次の数字が「０」の場合は「１０」を付加し、「０」以外の場合は「０」を付加すればよい。

「１」→「」
「２」→「１１」
「３」→「１１１１」
「４」→「１１１１１１」

上記のルールで符号化すると、先ほどの手牌は次のように符号化される。

「１３５７９一三五七九東南西北」
→「１０１０１０１０１０１０１０１０１０１０１０１０１０１」（符号化前）
→「１０１０１０１０１０１０１０１０１０１０１０１０１００」（符号化後）

符号化後はビット列となっているため、bit数は、符号化前81bitに対して符号化後は27bitになる。32bit以内であるため、インデックスとして扱いやすい。よって、和了の形を全て調べて上記ルールで符号化してインデックスとして保持することにする。
全ての和了の形の調べ方

手牌を連続した牌の個数で表現した場合、和了の形は、面子が順子か刻子かにより、次のパターンに分類される。

「１１１」「１１１」「１１１」「１１１」「２」（全て順子）
「１１１」「１１１」「１１１」「３」「２」（ひとつが刻子）
「１１１」「１１１」「３」「３」「２」（ふたつが刻子）
「１１１」「３」「３」「３」「２」（みっつが刻子）
「３」「３」「３」「３」「２」（よっつが刻子）
「２」「２」「２」「２」「２」「２」「２」（七対子）※七対子は例外扱いしなくてよい

これらに加えて、副露（ポン、チー、槓）がある場合の手牌も考慮して、

「１１１」「１１１」「１１１」「２」（全て順子、ひとつの副露）

というパターンも加える。

それぞれのパターンで、牌が重なる場合があるため、それらを考慮して全て列挙すればよい。たとえば全てが順子の場合、次のようなパターンがある。

「１１２１１」「１１１」「１１１」「２」
「２２２」「１１１」「１１１」「２」

また、牌を個数にする場合、牌の順番も考慮する必要がある。次の２つは異なる数字に変換される。

「１１３４５７８９一二三五六七」→「２」「１１１」「１１１」「１１１」「１１１」
「３４５７８９一二三五六七東東」→「１１１」「１１１」「１１１」「１１１」 「２」

牌の重なりと牌の順番の組み合わせを全て調べることでインデックスが完成する。
面子の構成を知る

和了かどうかを判定するにはインデックスを検索すればよいが、役を判定するには、どの牌が雀頭でどの牌が刻子か順子かがわかる必要がある。そのため、符号化する前の数字列の何番目が雀頭で何番目が刻子で何番目が順子であるかをインデックスとセットで保持することにする。面子の構成を保持するために、面子の構成を次のようなビット列で構成することにする。

下位
3bit    刻子の数
3bit    順子の数
4bit    雀頭の位置
4bit    面子の位置
4bit    面子の位置
4bit    面子の位置
4bit    面子の位置
上位

面子の位置は刻子→順子の順に埋めていくことにする。
役を事前に判定する

インデックスを作成するときに、連続する牌の個数の並びから一部の役が判定できる。たとえば、次のようなものが事前に判定できる。

「２２２」→一盃口
「２２２」「２２２」→二盃口
「２」「２」「２」「２」「２」「２」「２」→七対子
「４１１１１１１１１３」→九連宝燈
「１１１１１１１１１」→一気通貫

面子の構成とともに事前にわかる役についてもビット列にフラグとして保持することにする。

下位
3bit    刻子の数
3bit    順子の数
4bit    雀頭の位置
4bit    面子の位置
4bit    面子の位置
4bit    面子の位置
4bit    面子の位置
1bit    七対子フラグ
1bit    九蓮宝燈フラグ
1bit    一気通貫フラグ
1bit    二盃口フラグ
1bit    一盃口フラグ
上位
和了の組み合わせを求める

上記の通り、和了の組み合わせを全て列挙して符号化を行い、面子の構成の作成と役の事前判定を行う。配列が扱いやすいためRuby言語を使用してJava言語用のHashMap(またはTreeMap)を作成するコードを生成した。調べ上げた結果、和了の形のパターン数は、9362通りであった。

数値化した和了の形をJava言語のHashMapに追加した場合、ハッシュテーブルサイズがいくつになるか調べた。その結果、ハッシュテーブルサイズが16384となった。ハッシュテーブルを保持するために、少なくとも、32bit×16384=4byte×16384=65,536byte=約65KBが必要となる。これは、パソコンのメモリサイズからすると、十分に小さい。また、TreeMapとして保持する場合は、ハッシュテーブルサイズは不要となる。
インデックスを用いた方法の処理速度測定

インデックスを用いた方法で和了判定を行った場合の処理速度を測定した結果を以下に示す。比較のために通常の方法（バックトラック法）の処理時間も同時に記載した。

【10万回実行時の処理時間】（Java5、Pentium4 3.0GHzでの測定結果）

手牌：１２３５６７一二三五六七西西
バックトラック法    4297ms
インデックス法(HashMap)      94ms
インデックス法(TreeMap)      125ms

手牌：１１１２３４６７８東東東西西
バックトラック法    4391ms
インデックス法(HashMap)      94ms
インデックス法(TreeMap)      125ms

手牌：１１１２２２２３３３３４４４
バックトラック法    4891ms
インデックス法(HashMap)      94ms
インデックス法(TreeMap)      94ms

バックトラック法に比べて、45～50倍程度高速に判定できていることがわかる。また、手牌によらず、速度が安定している。
まとめ

麻雀の和了を判定するために、インデックスを用いることで高速に判定できることを示した。インデックスを利用する場合の利点を以下に示す。

・判定が高速に行える
・一部の役が事前に判定できる
・七対子を例外扱いしなくてよい
ソースコード

測定には以下のソースコードを使用した。
通常の方法（バックトラック法）
和了の組み合わせを全て列挙するRuby言語のプログラム
インデックスを用いた方法
点数計算アプレット

以下で公開しているアプレットではインデックスを用いた方法で和了の判定を行っている。
http://hp.vector.co.jp/authors/VA046927/mjscore/

[トップページへ]